%% Versuch 1
% Load ground truth 
% gTruthData = load('orbslamGroundTruth.mat');
% gTruth     = gTruthData.gTruth;

% gTruth = rigid3d(gRot,gTrans);

% from python get sofaGroundTruth_trans and sofaGroundTruth_trans 
% in sofa coordinates
% use homogeneous transformation to transform sofaGroundTruth into slam
% coordinates
% that means start in (0,0,0) and face positive z direction, x to the right
% sofaGroundTruth_trans is in quaternions, so has to be converted to
% rotation matrix first

save('groundTruth/sofaGroundTruth.mat',...
    'sofaGroundTruth_trans','sofaGroundTruth_rot');

% sofaToSlamTranslation = sofaGroundTruth_trans(1,:)';
% sofaToSlamRotation = quat2rotm(sofaGroundTruth_rot(1,:));
% sofaToSlamTransformation = [inv(sofaToSlamRotation),...
%                             -inv(sofaToSlamRotation)*sofaToSlamTranslation;...
%                             0 0 0 1];
% sofaGroundTruth_trans = sofaToSlamTransformation*[sofaGroundTruth_trans';...
%                                         ones(1,length(sofaGroundTruth_trans))];
% sofaGroundTruth_trans = sofaGroundTruth_trans(1:3,:);
%                         
%                         
%                         
% % just translate                      
% % sofaGroundTruth_trans =  sofaGroundTruth_trans - sofaGroundTruth_trans(1,:);
% 
% Plot the actual camera trajectory 
tweaked_plotU(mapPlot, sofaGroundTruth_trans, optimizedPoses);

% Show legend
showLegend(mapPlot);

% Evaluate tracking accuracy
tweaked_helperEstimateTrajectoryError(sofaGroundTruth_trans, optimizedPoses);



%% Versuch 2
% load groundTruth/sofaGroundTruth
% % Plot the actual camera trajectory 
% sofaToSlamTranslation = sofaGroundTruth_trans(1,:)';
% sofaToSlamRotation = quat2rotm(sofaGroundTruth_rot(1,:));
% sofaToSlamTransformation = [sofaToSlamRotation,...
%                             -sofaToSlamRotation*sofaToSlamTranslation;...
%                             0 0 0 1];
% sofaGroundTruth_trans = sofaToSlamTransformation*[sofaGroundTruth_trans';...
%                                         ones(1,length(sofaGroundTruth_trans))];
% sofaGroundTruth_trans = sofaGroundTruth_trans(1:3,:)';
% 
% 
% tweaked_plotUpdateScale(mapPlot, sofaGroundTruth_trans, optimizedPoses);
% tweaked_plotActualTrajectory(mapPlot, sofaGroundTruth_trans);
% 
% % Show legend
% showLegend(mapPlot);

% Evaluate tracking accuracy
% tweaked_helperEstimateTrajectoryError(sofaGroundTruth_trans, optimizedPoses);


%% Versuch 3 
% GG = @(A,B) [ dot(A,B) -norm(cross(A,B)) 0;...
%               norm(cross(A,B)) dot(A,B)  0;...
%               0              0           1];
% 
% FFi = @(A,B) [ A (B-dot(A,B)*A)/norm(B-dot(A,B)*A) cross(B,A) ];
% 
% UU = @(Fi,G) Fi*G*inv(Fi);
% 
% U = UU(FFi(a,b), GG(a,b));
% 
% disp(norm(U));
% disp(norm(b-U*a);


